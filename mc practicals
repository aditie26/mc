1st
Simple program for memory transfer 
#include <reg51.h>
void main(void)
{
    unsigned char x,y,z;
    x = 0x0A;
    y = 0x05;
    P1 = 0x00;
    z = x + y;
    P1 = z;
}

#include <reg51.h>
void main(void)
{
    unsigned char x,y,z;
    x = 0x08;
    y = 0x04;
    P1 = 0x00;
    z = x - y;
    P1 = z;
}

#include <reg51.h>
void main(void)
{
    unsigned char x,y,z;
    x = 0x10;
    y = 0x02;
    P1 = 0x00;
    z = x * y;
    P1 = z;
}

#include <reg51.h>
void main(void)
{
    unsigned char x,y,z;
    x = 0x10;
    y = 0x02;
    P1 = 0x00;
    z = x / y;
    P1 = z;
}

#include <reg51.h>
void main(void)
{
    unsigned char mynum[] = "012345ABCD";
    unsigned char z;
    for (z = 0; z <= 9; z++)
        P1 = mynum[z];
}

2nd
Blinking led alternate 
#include <reg51.h>

void delay(void);        // prototype

void main(void)
{
    while(1)             // INFINITE LOOP
    {
        P1 = 0x0F;       // lower nibble ON, upper nibble OFF
        delay();
        P1 = 0xF0;       // upper nibble ON, lower nibble OFF
        delay();
    }
}

void delay(void)
{
    TMOD = 0x01;        // Timer0 in mode 1 (16-bit); Timer1 cleared
    TH0 = 0xFF;         // high byte initial value
    TL0 = 0x0A;         // low byte initial value
    TR0 = 1;            // start Timer0
    while (TF0 == 0);   // wait until Timer0 overflow sets TF0
    TR0 = 0;            // stop Timer0
    TF0 = 0;            // clear overflow flag for next use
}

Toggling 
#include <reg51.h>

void delay(void);

void main(void)
{
    while(1)
    {
        P1 = 0xAA;       // pattern 10101010
        delay();
        P1 = 0x00;       // all OFF
        delay();
    }
}

void delay(void)
{
    TMOD = 0x01;
    TH0 = 0xFF;
    TL0 = 0x0A;
    TR0 = 1;
    while (TF0 == 0);
    TR0 = 0;
    TF0 = 0;
}

7 segment 
#include <reg51.h>

void delay(void);

void main(void)
{
    unsigned char code digits[] = {0x3F, 0x06, 0x5B, 0x4F, 
                                   0x66, 0x6D, 0x7D, 0x07, 
                                   0x7F, 0x6F}; // 0–9 pattern

    int i;

    while(1)
    {
        for(i = 0; i < 10; i++)
        {
            P0 = digits[i];  // send pattern for each number
            delay();
        }
    }
}

void delay(void)
{
    unsigned int j;
    for(j = 0; j < 50000; j++);
}
1.2
#include <reg51.h>

void delay(){
    int i;
    for(i=0; i<=12; i++){
        TMOD = 0x01;
        TL0 = 0x00;
        TH0 = 0x00;
        TR0 = 1;
        while(TF0 == 0);
        TR0 = 0;
        TF0 = 0;
    }    
}

unsigned char codes[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f}

void main(){
    int k;
    while(1){
        for(k=0; k<11; k++){
            P2 = codes[k];
            delay();
        }
    }
}
stepper
#include<reg51.h>
void delay();
void main()
{
unsigned char dat;
while(1)
{
dat=0x01;
P2=dat;
delay();
dat=0x02;
P2=dat;
delay();
dat=0x04;
P2=dat;
delay();
dat=0x08;
P2=dat;
delay();
}
}
void delay()
{
TMOD=0X10;
TH1=0X00;
TL1=0X00;
TR1=1;
while(TF1==0);
TR1=0;
TF1=0;
}

lcd interfacing 
#include<reg51.h>
#define lcd_data P1
sbit rs=P2^2;
sbit rw=P2^1;
sbit en=P2^0;
void  lcd_init();
void cmd(unsigned char a);
void dat(unsigned char b);
void show(unsigned char *s);
void lcd_delay();
void lcd_init()
{
cmd(0x38);
cmd(0x0e);
cmd(0x01);
cmd(0x06);
cmd(0x0c);
cmd(0x80);
}
void cmd(unsigned char a)
{
lcd_data=a;
rs=0;
rw=0;
en=1;
lcd_delay();
en=0;
}
void dat(unsigned char b)
{
lcd_data=b;
rs=1;
rw=0;
en=1;
lcd_delay();
en=0;}
void show(unsigned char *s){
while(*s){
dat(*s++); 
}
}
void lcd_delay()
{
unsigned int lcd_delay;
for(lcd_delay=0;lcd_delay<=6000;lcd_delay++);
}
int main()
{
unsigned int j;
lcd_init();
while(1)
{
cmd(0x80);
show("VISHAL");
cmd(0xc0);
show("RAJPUROHIT");

for(j=0;j<30000;j++);
cmd(0x01);
for(j=0;j<30000;j++);
}
}

lcd interfacing pic
#include <P18f4550.h>

#define LCD_EN LATAbits.LA1
#define LCD_RS LATAbits.LA0
#define LCDPORT PORTB

void lcd_delay(unsigned int timer) {
    unsigned int i, j;
    for (i = 0; i < timer; i++) {
        for (j = 0; j < 100; j++) {
            // Do nothing, just delay
        }
    }
}

void SendInstruction(unsigned char command) {
    LCD_RS = 0; 
    LCDPORT = command;
    LCD_EN = 1;
    lcd_delay(10);
    LCD_EN = 0;
    lcd_delay(10);
}

void SendData(unsigned char leddata) {
    LCD_RS = 1; // RS HIGH for DATA
    LCDPORT = leddata;
    LCD_EN = 1; // EN High
    lcd_delay(10);
    LCD_EN = 0; // EN Low; data sampled at EN falling edge
    lcd_delay(10);
}

void InitLCD(void) {
    ADCON1 = 0x0F; // Set digital I/O
    TRISB = 0x00; // Set data port as output
    TRISAbits.RA0 = 0; // RS pin
    TRISAbits.RA1 = 0; // EN pin

    // 8 bit mode, 2 line, 5x7 dots
    SendInstruction(0x38);
    SendInstruction(0x06); // Entry mode
    SendInstruction(0x0C); // Display ON, cursor OFF
    SendInstruction(0x01); // Clear display
    SendInstruction(0x80); // Set address to 1st line
}

unsigned char *String1 = "Aradhana Shukla"; // Initialize with a valid string
unsigned char *String2 = "Anushka Bankar"; // PIC-18F Board

void main(void) {
    InitLCD(); // Initialize the LCD

    while (*String1) {
        SendData(*String1);
        String1++;
    }

    // Set address to 2nd line
    SendInstruction(0xC0);

    while (*String2) {
        SendData(*String2);
        String2++;
    }

    while (1) {
        // Infinite loop
    }
}

relay,buzzer pic
#include<p18F4550.h>
void delay(){
    unsigned int i;
    for(i=0;i<30000;i++);
}
void main(){
    unsigned char i,key=0;
    TRISB=0x00;
    //LATB=0x00;
    ADCON1=0x0F;
    TRISAbits.TRISA2=1;
    TRISAbits.TRISA3=1;
    TRISAbits.TRISA5=0;
    TRISAbits.TRISA4=0;
    while(1){
        //LATAbits.LA2=1;
        //LATAbits.LA3=1;
        if(PORTAbits.RA2==0) key=0;
        if(PORTAbits.RA3==0) key=1;
        if(key==0){
            PORTAbits.RA4==0;
            PORTAbits.RA5==1;
            for(i=0;i<8;i++)
            {
                PORTB=1<<i;
                delay();
                PORTB =0X00;
                delay();
            }
        }
        if(key==1){
            PORTAbits.RA4=0;
            PORTAbits.RA5=1;
            for(i=7;i>0;i--){
                PORTB=1<<i;
                delay();
                PORTB=0x00;
                delay();

            }
        }
    }
}




led pic
#include<p18f4550.h>
void delay(unsigned int time)
{
    unsigned int i,j;
    for(i=0;i<time;i++)
        for(j=0;j<5000;j++);
}
void main(void)
{
    TRISB=0x00;
    while(1)
    {
        PORTB=0x00;
        delay(100);
        PORTB=0xFF;
        delay(100);
    }
}

square wave
#include <reg51.h>

sbit wave = P2^1;

void timer0(void) interrupt 1
{
    wave = ~wave;
}

void main()
{
    while(1)
    {
        TMOD = 0x01;
        TH0 = 0xFF;
        TL0 = 0xF9;
        IE = 0x82;
        TR0 = 1;
    }
}

ADC-LCD
#include <p18f4550.h>
#include<stdio.h>
#define LCD_EN LATAbits.LA1
#define LCD_RS LATAbits.LA0
#define LCDPORT LATB
void lcd_delay(unsigned int time){
unsigned int i , j ;
for(i = 0; i < time; i++){
    for(j=0;j<50;j++);
}
}
void SendInstruction(unsigned char command)
{
    LCD_RS = 0; // RS low : Instruction
    LCDPORT = command;
    LCD_EN = 1; // EN High
    lcd_delay(10);
    LCD_EN = 0; // EN Low; command sampled at EN falling edge
    lcd_delay(10);
}
void SendData(unsigned char lcddata){
    LCD_RS = 1; // RS HIGH : DATA
    LCDPORT = lcddata;
    LCD_EN = 1; // EN High
    lcd_delay(10);
    LCD_EN = 0; // EN Low; data sampled at EN falling edge
    lcd_delay(10);
}
void InitLCD(void)
{
    ADCON1 = 0x0F;
    TRISB = 0x00; //set data port as output
    TRISAbits.RA0 = 0; //RS pin
    TRISAbits.RA1 = 0; // EN pin
    SendInstruction(0x38); //8 bit mode, 2 line,5x7 dots
    SendInstruction(0x06); // entry mode
    SendInstruction(0x0C); //Display ON cursor OFF
    SendInstruction(0x01); //Clear display
    SendInstruction(0x80); //set address to 0
}
void ADCInit(void)
{
    TRISEbits.RE1 = 1; //ADC channel 6 input
    TRISEbits.RE2 = 1; //ADC channel 7 input
    ADCON1 = 0b00000111; //Ref voltages Vdd & Vss; AN0 - AN7 channelsAnalog
    ADCON2 = 0b10101110; //Right justified; Acquisition time 12T; Conversionclock Fosc/64
}
unsigned short Read_ADC(unsigned char Ch)
{
    ADCON0 = 0b00000001 | (Ch<<2); //ADC on; Select channel;
    GODONE = 1; //Start Conversion
    while(GO_DONE == 1 ); //Wait till A/D conversion is complete
    return ADRES; //Return ADC result
}
void DisplayResult(unsigned short ADCVal)
{
    unsigned char i,text[16];
    unsigned short tempv;
    tempv = ADCVal;
    SendInstruction(0x80); //set to 1st line
    for(i=0;i<10;i++) //Display the 10 bit ADC result on LCD
    {
    if(tempv & 0x200)
    {
    SendData('1');
    }
    else
    {
    SendData('0');
    }
    tempv = tempv<<1;
    }
    ADCVal = (5500/1024)*ADCVal; //Convert binary data to mV; 1 bit <=>(5500/1024)mV
    sprintf(text,"ADC value=%4dmv",ADCVal); //Convert integer data to string
    SendInstruction(0xC0); //set to 2nd line
    for(i=0;i<16;i++) //Display string on LCD
    {
        SendData(text[i]);
    }
}
void main()
{
    unsigned short Ch_result;
    TRISB = 0x00; //PORTB connected to LCD is output
    ADCInit();
    InitLCD();
    while(1)
    {
        Ch_result = Read_ADC(7);
        DisplayResult(Ch_result);
        lcd_delay(1000);
    }
}

PWM DC
#include <p18f4550.h>

void timer2Init(void)
{
    T2CON = 0b00000100; // Prescaler = 16; Timer2 ON (set the TMR2ON bit here)
    PR2 = 0x95; // Period Register for 200us
}

void delay(unsigned int time)
{
    unsigned int i, j;
    for (i = 0; i < time; i++)
        for (j = 0; j < 1000; j++);
}

void main(void)
{
    unsigned int i;
    TRISCbits.TRISC1 = 0; // RC1 pin as output
    TRISCbits.TRISC2 = 0; // CCP1 pin as output
    LATCbits.LATC1 = 0;

    CCP1CON = 0b00111100; // Select PWM mode; Duty cycle LSB
    CCP1CONbits.CCP1M3 = 1; // Set bit 3
    CCP1CONbits.CCP1M2 = 1; // Set bit 2

    CCPR1L = 0x0F; // Duty cycle 10%
    timer2Init(); // Initialize Timer2

    TMR2ON = 1; // Timer2 ON

    while (1) // Loop forever
    {
        for (i = 15; i < 150; i++)
        {
            CCPR1L = i; // Adjust duty cycle
            delay(100); // Delay for visibility
        }
        for (i = 150; i > 15; i--)
        {
            CCPR1L = i; // Adjust duty cycle
            delay(100); // Delay for visibility
        }
    }
}

